.regex
    // Replace and leave it as such
    &and:(as well as|and also)

    // Replace, but finally resolve to actual value
    P_SIZE:@small

.train
    // The goal is isolate slot types(!) and replace them by the type name, so next layer - has
    // less samples to be trained with
    (ORDER_PIZZA|) @kind{&P_KIND}

    (ORDER_PIZZA|) @toppings{&P_TOPPINGS} on top

    (ORDER_PIZZA|) @i @want (P_SIZE|) @kind{&P_KIND} @pizza (with|)

    (ORDER_PIZZA|) @i @want @kind{&P_KIND} @and @kind{&P_KIND} @pizza (with|)

    (ORDER_PIZZA|) @i @want @extra @toppings{&P_TOPPINGS} on top

    (ORDER_PIZZA|) @i @want @extra @toppings{&P_TOPPINGS} @and @extra @toppings{&P_TOPPINGS} on top

    (ORDER_PIZZA|) @i @want @pizza with @extra @toppings{&P_TOPPINGS}

    (ORDER_PIZZA|) on top @i @want @extra @toppings{&P_TOPPINGS}

    (ORDER_PIZZA|) add (topping|toppings) @extra @toppings{&P_TOPPINGS}

    (ORDER_PIZZA|) add @toppings{&P_TOPPINGS} on top
    
    (ORDER_PIZZA|) (my|@the) address is @address{&P_ADDRESS}
    
    (ORDER_PIZZA|) @i live in @address{&P_ADDRESS}


