// Slots types training. Ex: small -> P_SIZE, bbq -> P_KING, ham-> P_TOPPINGS, ...
.regex
    // Lookup label replacement
    // Replace all values of @small definition by P_SIZE.
    // At the end of deduction it will be replaced by its origial value.
    // P_SIZE will be used for training, not all values of @small
    P_SIZE:@small

    // Prefix & is to indicate simple replacement
    // Ex utterance:  
    // 'I want bbq pizza as well as hawaiian' => 'I want bbq pizza and hawaiian'
    &and:(as well as|and also)


// The goal is isolate slot types(!) and replace them by the type name, so next layer - has
// less samples to be trained with
.train
    // All values of @kind are used for training
    @kind{&P_KIND} pizza

    ASK_KIND @kind{&P_KIND}

    ASK_KIND @kind{&P_KIND} and @kind{&P_KIND}

    ASK_TOPPINGS @toppings{&P_TOPPINGS}

    ASK_TOPPINGS @toppings{&P_TOPPINGS} and @toppings{&P_TOPPINGS}

    @want @toppings{&P_TOPPINGS} on top

    @want (P_SIZE|) @pizza

    @want (P_SIZE|) @kind{&P_KIND}

    @want (P_SIZE|) @kind{&P_KIND} @pizza

    @want @kind{&P_KIND} @pizza
    
    @and @kind{&P_KIND} @pizza

    @want @extra @toppings{&P_TOPPINGS} on top

    @want @extra @toppings{&P_TOPPINGS}

    with @extra @toppings{&P_TOPPINGS} and @toppings{&P_TOPPINGS}

    @want @pizza with @extra @toppings{&P_TOPPINGS}

    on top @i @want @extra @toppings{&P_TOPPINGS}

    add @toppings{&P_TOPPINGS} on top
    
    (my|@the) address is @address{&P_ADDRESS}
    
    live in @address{&P_ADDRESS}

    address is @address{&P_ADDRESS}

    ASK_ADDRESS @address{&P_ADDRESS}

    ASK_ADDRESS @address{&P_ADDRESS} this is where i live

    @i @want to order pizza
    @i @want to place an order for pizza
    pizza please

    @yes
    @no
